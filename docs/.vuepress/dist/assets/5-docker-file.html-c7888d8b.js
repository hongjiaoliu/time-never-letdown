import{_ as s,V as a,W as n,Z as e}from"./framework-bcbeea85.js";const t={},l=e(`<h1 id="_5-docker-file" tabindex="-1"><a class="header-anchor" href="#_5-docker-file" aria-hidden="true">#</a> 5-Docker File</h1><h2 id="什么是-dockerfile" tabindex="-1"><a class="header-anchor" href="#什么是-dockerfile" aria-hidden="true">#</a> 什么是 Dockerfile？</h2><p>Dockerfile 是一个用来构建镜像的文本文件，文本内容包含了一条条构建镜像所需的指令和说明。</p><h2 id="使用-dockerfile-定制镜像" tabindex="-1"><a class="header-anchor" href="#使用-dockerfile-定制镜像" aria-hidden="true">#</a> 使用 Dockerfile 定制镜像</h2><h2 id="docker-file-指令" tabindex="-1"><a class="header-anchor" href="#docker-file-指令" aria-hidden="true">#</a> Docker file 指令</h2><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code> FROM 这个镜像的妈妈是谁？（指定基础镜像）

 MAINTAINER 告诉别人，谁负责养它？（指定维护者信息，可以没有）

 RUN 你想让它干啥（在命令前加上RUN即可）

 ADD 添加宿主机的文件到容器内
 
 COPY 作用和ADD一样的，都是拷贝宿主机文件到容器内，但ADD会自动解压

 WORKDIR 我是cd,今天刚化了妆（设置当前工作目录）

 VOLUME 给它一个存放行李的地方（设置卷，挂载主机目录）

 EXPOSE 它要打开的门是啥（指定对外的端口）

 CMD 奔跑吧，兄弟！（指定容器启动后的要干的事情）

</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>其它指令</p><div class="language-perl line-numbers-mode" data-ext="perl"><pre class="language-perl"><code>
 ENV 环境变量

 ENTRYPOINT 容器启动后执行的命令
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2 id="from" tabindex="-1"><a class="header-anchor" href="#from" aria-hidden="true">#</a> FROM</h2><p>指定基础镜像。一般格式如下，<code>[]</code>括号内容可省略：</p><div class="language-perl line-numbers-mode" data-ext="perl"><pre class="language-perl"><code>FROM <span class="token punctuation">[</span><span class="token operator">--</span>platform<span class="token operator">=</span><span class="token filehandle symbol">&lt;platform&gt;</span><span class="token punctuation">]</span> <span class="token filehandle symbol">&lt;image&gt;</span><span class="token punctuation">[</span><span class="token punctuation">:</span><span class="token filehandle symbol">&lt;tag&gt;</span><span class="token punctuation">]</span> <span class="token punctuation">[</span>AS <span class="token filehandle symbol">&lt;name&gt;</span><span class="token punctuation">]</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>特别需要注意的是<code>FROM</code>在一个dockerfile中可以多次出现，以实现多阶段构建。并且可以和ARG 参数交互。</p><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code>ARG  <span class="token assign-left variable">CODE_VERSION</span><span class="token operator">=</span>latest
FROM base:<span class="token variable">\${CODE_VERSION}</span>
CMD  /code/run-app
​
FROM extras:<span class="token variable">\${CODE_VERSION}</span>
CMD  /code/run-extras
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2 id="run" tabindex="-1"><a class="header-anchor" href="#run" aria-hidden="true">#</a> RUN</h2><p>RUN的两种形式</p><ul><li>RUN 首选， (命令在shell中运行,即默认为/bin/sh -c )</li><li>RUN [&quot;exec&quot;,param1,param2]</li></ul><p>RUN命令主要是在镜像构建时执行，形成新层。比如我们经常会看到在构建镜像时安装相关软件。</p><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>RUN yum install -y gcc 
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>当我们不想使用默认shell是可以采用exec形式实现</p><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>RUN [&quot;/bin/bash&quot;,&quot;-c&quot;,&quot;yum install -y gcc&quot;]
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>当然，exec形式可以不使用shell</p><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>RUN [&quot;yum&quot;,&quot;install&quot;,&quot;-y&quot;,&quot;gcc&quot;]
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p><em>EXEC</em>形式被解析为一个JSON阵列，所以必须使用双引号</p><h2 id="cmd" tabindex="-1"><a class="header-anchor" href="#cmd" aria-hidden="true">#</a> CMD</h2><p><code>CMD</code>指令有三种形式：</p><ul><li><p><code>CMD [&quot;executable&quot;,&quot;param1&quot;,&quot;param2&quot;]</code>（<em>exec</em>形式，这是首选形式）</p></li><li><p><code>CMD [&quot;param1&quot;,&quot;param2&quot;]</code>（作为<em>ENTRYPOINT 的默认参数</em>）</p></li><li><p><code>CMD command param1 param2</code>（shell形式）</p></li></ul><p>一个dockerfile中，应该只写一个CMD，如果有多个只有最后一个生效。在实际编写dockerfie时CMD命令常常用于为<em>ENTRYPOINT</em>提供默认值，后面我们会讲到。</p><p><strong>与RUN相比，CMD在构建时不会执行任何操作，主要用于指定镜像的启动命令。CMD的启动命令可以被docker run 参数代替。</strong></p><p>我们在dockerfile中添加如下CMD命令</p><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code>CMD <span class="token builtin class-name">echo</span> hello
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>构建镜像后，docker run 不添加参数，启动容器</p><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code><span class="token punctuation">[</span>root@localhost dockerfiles<span class="token punctuation">]</span><span class="token comment"># docker run centos:v1</span>
hello
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>当我们在docker run 添加参数后</p><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code><span class="token punctuation">[</span>root@localhost dockerfiles<span class="token punctuation">]</span><span class="token comment"># docker run centos_env:v1 echo container</span>
container 
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>显然我们CMD命令echo hello已被docker run中的参数echo container取代。</p><h2 id="label" tabindex="-1"><a class="header-anchor" href="#label" aria-hidden="true">#</a> LABEL</h2><p>label用于添加镜像的元数据，采用key-value的形式。</p><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code>LABEL <span class="token operator">&lt;</span>key<span class="token operator">&gt;=</span><span class="token operator">&lt;</span>value<span class="token operator">&gt;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>比如我们添加如下LABEL</p><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code>LABEL <span class="token string">&quot;miantainer&quot;</span><span class="token operator">=</span><span class="token string">&quot;iqsing.github.io&quot;</span>
LABEL <span class="token string">&quot;version&quot;</span><span class="token operator">=</span><span class="token string">&quot;v1.2&quot;</span>
LABEL <span class="token string">&quot;author&quot;</span><span class="token operator">=</span><span class="token string">&quot;waterman&amp;&amp;iqsing&quot;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>为了防止创建三层，我们最好通过一个标签来写。</p><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code>LABEL <span class="token string">&quot;miantainer&quot;</span><span class="token operator">=</span><span class="token string">&quot;iqsing.github.io&quot;</span> <span class="token punctuation">\\</span>
      <span class="token string">&quot;version&quot;</span><span class="token operator">=</span><span class="token string">&quot;v1.2&quot;</span> <span class="token punctuation">\\</span>
      <span class="token string">&quot;author&quot;</span><span class="token operator">=</span><span class="token string">&quot;waterman&amp;&amp;iqsing&quot;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>我们通过docker inspect 来查看镜像label信息</p><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code><span class="token comment">#docker inspect centos_labels:v1</span>
​
<span class="token string">&quot;Labels&quot;</span><span class="token builtin class-name">:</span> <span class="token punctuation">{</span>
    <span class="token string">&quot;author&quot;</span><span class="token builtin class-name">:</span> <span class="token string">&quot;waterman&amp;&amp;iqsing&quot;</span>,
    <span class="token string">&quot;miantainer&quot;</span><span class="token builtin class-name">:</span> <span class="token string">&quot;iqsing.github.io&quot;</span>,
    <span class="token string">&quot;org.label-schema.build-date&quot;</span><span class="token builtin class-name">:</span> <span class="token string">&quot;20201204&quot;</span>,
    <span class="token string">&quot;org.label-schema.license&quot;</span><span class="token builtin class-name">:</span> <span class="token string">&quot;GPLv2&quot;</span>,
    <span class="token string">&quot;org.label-schema.name&quot;</span><span class="token builtin class-name">:</span> <span class="token string">&quot;CentOS Base Image&quot;</span>,
    <span class="token string">&quot;org.label-schema.schema-version&quot;</span><span class="token builtin class-name">:</span> <span class="token string">&quot;1.0&quot;</span>,
    <span class="token string">&quot;org.label-schema.vendor&quot;</span><span class="token builtin class-name">:</span> <span class="token string">&quot;CentOS&quot;</span>,
    <span class="token string">&quot;version&quot;</span><span class="token builtin class-name">:</span> <span class="token string">&quot;v1.2&quot;</span>
<span class="token punctuation">}</span>
​
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2 id="expose" tabindex="-1"><a class="header-anchor" href="#expose" aria-hidden="true">#</a> EXPOSE</h2><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code>EXPOSE <span class="token number">80</span>/tcp
EXPOSE <span class="token number">161</span>/udp
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>注意，EXPOSE只是告诉dockerfile的阅读者，我们构建的镜像需要暴露哪些端口，只是一个信息。在容器中还是需要通过<code>-p</code>选项来暴露端口。</p><h2 id="env" tabindex="-1"><a class="header-anchor" href="#env" aria-hidden="true">#</a> ENV</h2><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code>ENV <span class="token operator">&lt;</span>key<span class="token operator">&gt;=</span><span class="token operator">&lt;</span>value<span class="token operator">&gt;</span> <span class="token punctuation">..</span>. 首先方式
或
ENV <span class="token operator">&lt;</span>key<span class="token operator">&gt;</span>  <span class="token operator">&lt;</span>value<span class="token operator">&gt;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>通过ENV指定环境变量，将作用于在构建阶段的所有后续指令的环境中。</p><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code>ENV <span class="token assign-left variable">username</span><span class="token operator">=</span><span class="token string">&quot;iqsing&quot;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>这样当我们启动这个容器后可以查看到容器信息已经附带了<code>ENV</code>环境变量</p><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code><span class="token string">&quot;Env&quot;</span><span class="token builtin class-name">:</span> <span class="token punctuation">[</span>
<span class="token string">&quot;PATH=/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin&quot;</span>,
<span class="token string">&quot;username=iqsing&quot;</span>
<span class="token punctuation">]</span>,
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>当然我们也可以在启动容器时添加环境变量</p><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code><span class="token function">docker</span> run <span class="token parameter variable">--env</span> <span class="token operator">&lt;</span>key<span class="token operator">&gt;=</span><span class="token operator">&lt;</span>value<span class="token operator">&gt;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>另外如果只需要在镜像构建期间使用环境变量，更好的选择是使用<code>ARG</code>参数来处理</p><h2 id="add-copy" tabindex="-1"><a class="header-anchor" href="#add-copy" aria-hidden="true">#</a> ADD &amp;&amp; COPY</h2><p>ADD和COPY格式相似，有两种形式,包含空格的路径需要后一种形式：</p><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code>ADD <span class="token punctuation">[</span>--chown<span class="token operator">=</span><span class="token operator">&lt;</span>user<span class="token operator">&gt;</span>:<span class="token operator">&lt;</span>group<span class="token operator">&gt;</span><span class="token punctuation">]</span> <span class="token operator">&lt;</span>src<span class="token operator">&gt;</span><span class="token punctuation">..</span>. <span class="token operator">&lt;</span>dest<span class="token operator">&gt;</span>
ADD <span class="token punctuation">[</span>--chown<span class="token operator">=</span><span class="token operator">&lt;</span>user<span class="token operator">&gt;</span>:<span class="token operator">&lt;</span>group<span class="token operator">&gt;</span><span class="token punctuation">]</span> <span class="token punctuation">[</span><span class="token string">&quot;&lt;src&gt;&quot;</span>,<span class="token punctuation">..</span>. <span class="token string">&quot;&lt;dest&gt;&quot;</span><span class="token punctuation">]</span>
​
COPY <span class="token punctuation">[</span>--chown<span class="token operator">=</span><span class="token operator">&lt;</span>user<span class="token operator">&gt;</span>:<span class="token operator">&lt;</span>group<span class="token operator">&gt;</span><span class="token punctuation">]</span> <span class="token operator">&lt;</span>src<span class="token operator">&gt;</span><span class="token punctuation">..</span>. <span class="token operator">&lt;</span>dest<span class="token operator">&gt;</span>
COPY <span class="token punctuation">[</span>--chown<span class="token operator">=</span><span class="token operator">&lt;</span>user<span class="token operator">&gt;</span>:<span class="token operator">&lt;</span>group<span class="token operator">&gt;</span><span class="token punctuation">]</span> <span class="token punctuation">[</span><span class="token string">&quot;&lt;src&gt;&quot;</span>,<span class="token punctuation">..</span>. <span class="token string">&quot;&lt;dest&gt;&quot;</span><span class="token punctuation">]</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>在linux平台中可以对添加到远程目录或文件设置所属用户和组。</p><p><code>&lt;SRC&gt;</code>指复制新文件、目录或远程文件 URL，每<code>&lt;src&gt;</code>可以包含通配符，如下：</p><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code>ADD hom* /mydir/
ADD hom?.txt /mydir/
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>一般使用中，ADD、COPY都遵守以下规则：</p><ul><li><code>&lt;src&gt;</code>路径必须是内部<em>语境</em>的构建; 你不能<code>COPY ../something /something</code>，因为 <code>docker build</code>是将上下文目录（和子目录）发送到 docker 守护进程。</li><li>如果<code>&lt;src&gt;</code>是目录，则复制目录的全部内容，包括文件系统元数据。</li><li>如果<code>&lt;src&gt;</code>是任何其他类型的文件，则将其与其元数据一起单独复制。在这种情况下，如果<code>&lt;dest&gt;</code>以斜杠结尾<code>/</code>，它将被视为一个目录，其内容<code>&lt;src&gt;</code>将被写入<code>&lt;dest&gt;/base(&lt;src&gt;)</code>。</li><li>如果<code>&lt;src&gt;</code>直接指定了多个资源，或者由于使用了通配符，则<code>&lt;dest&gt;</code>必须是目录，并且必须以斜杠结尾<code>/</code>。</li><li>如果<code>&lt;dest&gt;</code>不以斜杠结尾，则将其视为常规文件，并将其内容<code>&lt;src&gt;</code>写入<code>&lt;dest&gt;</code>.</li><li>如果<code>&lt;dest&gt;</code>不存在，则在其路径中创建所有丢失的目录。</li></ul><p><strong>特别的，当是可识别的压缩包如gzip、bzip2等tar包时，首先会将包添加到镜像中，然后自动解压。这可以说是与COPY命令在使用中的最大的区别。</strong></p><h2 id="entrypoint" tabindex="-1"><a class="header-anchor" href="#entrypoint" aria-hidden="true">#</a> ENTRYPOINT</h2><p>exec首选和shell形式:</p><div class="language-perl line-numbers-mode" data-ext="perl"><pre class="language-perl"><code>ENTRYPOINT <span class="token punctuation">[</span><span class="token string">&quot;executable&quot;</span><span class="token punctuation">,</span> <span class="token string">&quot;param1&quot;</span><span class="token punctuation">,</span> <span class="token string">&quot;param2&quot;</span><span class="token punctuation">]</span>
ENTRYPOINT command param1 param2
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>ENTRYPOINT 和CMD很相似，都是指定启动命令，不同之处在于ENTRYPOINT 指定的命令无法被docker run 参数取代。</strong></p><p>我们在dockerfile中添加ENTRYPOINT</p><div class="language-perl line-numbers-mode" data-ext="perl"><pre class="language-perl"><code>ENTRYPOINT echo hello container
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>构建镜像并启动容器，可以看到docker run 中的参数并未取代ENTRYPOINT</p><div class="language-perl line-numbers-mode" data-ext="perl"><pre class="language-perl"><code><span class="token punctuation">[</span>root<span class="token variable">@localhost</span> dockerfiles<span class="token punctuation">]</span><span class="token comment"># docker run centos_entrtpoint:v1 echo hello docker</span>
hello container
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>这指令优秀的另一个地方在于可以和CMD指令做交互。让容器以应用或者服务运行。</strong></p><p>经典操作：<code>ENTRYPOINT</code> + <code>CMD</code> = 默认容器命令参数</p><h2 id="volume" tabindex="-1"><a class="header-anchor" href="#volume" aria-hidden="true">#</a> VOLUME</h2><div class="language-perl line-numbers-mode" data-ext="perl"><pre class="language-perl"><code>VOLUME <span class="token punctuation">[</span><span class="token string">&quot;/data&quot;</span><span class="token punctuation">]</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>volume指令可以用于创建存储卷，我来看一下实例：</p><div class="language-perl line-numbers-mode" data-ext="perl"><pre class="language-perl"><code>FROM centos
RUN mkdir <span class="token operator">/</span>volume
RUN echo <span class="token string">&quot;hello world&quot;</span> <span class="token operator">&gt;</span> <span class="token operator">/</span>volume<span class="token operator">/</span>greeting
VOLUME <span class="token operator">/</span>volume
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>构建镜像后，创建一个容器</p><div class="language-perl line-numbers-mode" data-ext="perl"><pre class="language-perl"><code><span class="token punctuation">[</span>root<span class="token variable">@localhost</span> dockerfiles<span class="token punctuation">]</span><span class="token comment"># docker create   --name centos_volume  centos_volue:v1</span>
<span class="token punctuation">[</span>root<span class="token variable">@localhost</span> dockerfiles<span class="token punctuation">]</span><span class="token comment"># docker inspect centos_volume </span>
​
 <span class="token string">&quot;Mounts&quot;</span><span class="token punctuation">:</span> <span class="token punctuation">[</span>
            <span class="token punctuation">{</span>
                <span class="token string">&quot;Type&quot;</span><span class="token punctuation">:</span> <span class="token string">&quot;volume&quot;</span><span class="token punctuation">,</span>
                <span class="token string">&quot;Name&quot;</span><span class="token punctuation">:</span> <span class="token string">&quot;494cdb193984680045c36a16bbc2b759cf568b55c7e9b0852ccf6dff8bf79c46&quot;</span><span class="token punctuation">,</span>
                <span class="token string">&quot;Source&quot;</span><span class="token punctuation">:</span> <span class="token string">&quot;/var/lib/docker/volumes/494cdb193984680045c36a16bbc2b759cf568b55c7e9b0852ccf6dff8bf79c46/_data&quot;</span><span class="token punctuation">,</span>
                <span class="token string">&quot;Destination&quot;</span><span class="token punctuation">:</span> <span class="token string">&quot;/volume&quot;</span><span class="token punctuation">,</span>
                <span class="token string">&quot;Driver&quot;</span><span class="token punctuation">:</span> <span class="token string">&quot;local&quot;</span><span class="token punctuation">,</span>
                <span class="token string">&quot;Mode&quot;</span><span class="token punctuation">:</span> <span class="token string">&quot;&quot;</span><span class="token punctuation">,</span>
                <span class="token string">&quot;RW&quot;</span><span class="token punctuation">:</span> true<span class="token punctuation">,</span>
                <span class="token string">&quot;Propagation&quot;</span><span class="token punctuation">:</span> <span class="token string">&quot;&quot;</span>
            <span class="token punctuation">}</span>
        <span class="token punctuation">]</span><span class="token punctuation">,</span>
​
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>这样我们就通过VOLUME指令创建一个存储卷，你可以通过<code>--volumes-from</code>共享这个容器</p><h2 id="user" tabindex="-1"><a class="header-anchor" href="#user" aria-hidden="true">#</a> USER</h2><p>指定指令集所属用户和组。组默认为root。可以作用于<code>RUN</code>，<code>CMD</code>和 <code>ENTRYPOINT</code>它们后面的指令。</p><div class="language-perl line-numbers-mode" data-ext="perl"><pre class="language-perl"><code>USER <span class="token filehandle symbol">&lt;user&gt;</span><span class="token punctuation">[</span><span class="token punctuation">:</span><span class="token filehandle symbol">&lt;group&gt;</span><span class="token punctuation">]</span>
或
USER <span class="token filehandle symbol">&lt;UID&gt;</span><span class="token punctuation">[</span><span class="token punctuation">:</span><span class="token filehandle symbol">&lt;GID&gt;</span><span class="token punctuation">]</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2 id="workdir" tabindex="-1"><a class="header-anchor" href="#workdir" aria-hidden="true">#</a> WORKDIR</h2><p>指定指令集所在的工作目录，若目录不存在将会自动创建。可作用于<code>RUN</code>，<code>CMD</code>， <code>ENTRYPOINT</code>，<code>COPY</code>和<code>ADD</code></p><div class="language-perl line-numbers-mode" data-ext="perl"><pre class="language-perl"><code>WORKDIR <span class="token operator">/</span>path<span class="token operator">/</span>to<span class="token operator">/</span>workdir
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><h2 id="arg" tabindex="-1"><a class="header-anchor" href="#arg" aria-hidden="true">#</a> ARG</h2><div class="language-perl line-numbers-mode" data-ext="perl"><pre class="language-perl"><code>ARG <span class="token filehandle symbol">&lt;name&gt;</span><span class="token punctuation">[</span><span class="token operator">=</span><span class="token operator">&lt;</span><span class="token keyword">default</span> value<span class="token operator">&gt;</span><span class="token punctuation">]</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p><code>ARG</code>指令定义了一个变量，我们可以在<code>docker build</code>通过使用<code>--build-arg &lt;varname&gt;=&lt;value&gt;</code> 标志的命令将其传递给构建器。</p><ul><li>如果<code>ARG</code>指令具有默认值并且在构建时没有传递任何值，则构建器使用默认值。</li><li>在多阶段构建应该添加多个ARG</li><li>ENV变量会覆盖ARG变量</li><li>与ENV变量相比，ARG变量多用于构建，无法驻留在镜像中。</li></ul><h2 id="stopsignal" tabindex="-1"><a class="header-anchor" href="#stopsignal" aria-hidden="true">#</a> STOPSIGNAL</h2><p>配置容器退出时的系统调用</p><div class="language-perl line-numbers-mode" data-ext="perl"><pre class="language-perl"><code>STOPSIGNAL signal
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><h2 id="healthcheck" tabindex="-1"><a class="header-anchor" href="#healthcheck" aria-hidden="true">#</a> HEALTHCHECK</h2><p><code>HEALTHCHECK</code>指令有两种形式：</p><ul><li><code>HEALTHCHECK [OPTIONS] CMD command</code> （通过在容器内运行命令来检查容器健康状况）</li><li><code>HEALTHCHECK NONE</code> （禁用从基础镜像继承的任何健康检查）</li></ul><p>OPTIONS支持如下参数：</p><ul><li><code>--interval=DURATION</code>（默认值：<code>30s</code>）</li><li><code>--timeout=DURATION</code>（默认值：<code>30s</code>）</li><li><code>--start-period=DURATION</code>（默认值：<code>0s</code>）</li><li><code>--retries=N</code>（默认值：<code>3</code>）</li></ul><p>比如我们可以添加如下参数用于检查web服务：</p><div class="language-perl line-numbers-mode" data-ext="perl"><pre class="language-perl"><code>HEALTHCHECK <span class="token operator">--</span>interval<span class="token operator">=</span>5m <span class="token operator">--</span>timeout<span class="token operator">=</span>3s <span class="token operator">\\</span>
  CMD curl <span class="token operator">-f</span> http<span class="token punctuation">:</span><span class="token operator">/</span><span class="token regex">/localhost/</span> <span class="token operator">||</span> exit <span class="token number">1</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>每五分钟左右检查一次web服务器能否在3s内响应。如果失败则返回状态码1</p><p>命令的退出状态指示容器的健康状态。可能的值为：</p><ul><li>0：成功 - 容器运行良好，可以使用</li><li>1：不健康 - 容器无法正常工作</li><li>2：reserved - 不要使用这个退出代码</li></ul>`,105),o=[l];function i(c,p){return a(),n("div",null,o)}const d=s(t,[["render",i],["__file","5-docker-file.html.vue"]]);export{d as default};
